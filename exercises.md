# Exercises 8

## 9.1

The following code has been obtained by compiling and disassembling the selsort program.
The `-o` flag was used in compilation.
It has been annotated to describe the purpose of the instructions.

```{}
default void SelectionSort (int32[] arr)  cil managed 
    {
        // Method begins at RVA 0x20b8
    // Code size 57 (0x39)
    .maxstack 4                // There are only four local in use at the same time in the function.
                            // That is i, least, tmp, j in that order. All are ints, as seen below. 
    .locals init (
        int32    V_0,
        int32    V_1,
        int32    V_2,
        int32    V_3)
    IL_0000:  ldc.i4.0             // push 0 to the stack
    IL_0001:  stloc.0             // assign 0 to i, the 0'th local var
    IL_0002:  br.s IL_0032        // goto IL_0032

    IL_0004:  ldloc.0             // load i,
    IL_0005:  stloc.1             // store i in least, the 1'st local var
    IL_0006:  ldloc.0             // load i
    IL_0007:  ldc.i4.1             // push 1 to the stack
    IL_0008:  add                 // add the top two elements together
    IL_0009:  stloc.3             // store the top of the stack, in j, the 3'rd var
    IL_000a:  br.s IL_001a        // goto IL_001a

    IL_000c:  ldarg.0             // load the 0'th element in the function parameters, the full int array
    IL_000d:  ldloc.3             // load j
    IL_000e:  ldelem.i4         // get the j'th element from the array arr
    IL_000f:  ldarg.0             // load the int array
    IL_0010:  ldloc.1             // load least
    IL_0011:  ldelem.i4         // get the least'th element from the array arr
    IL_0012:  bge.s IL_0016        // jump to IL_0016, iff (arr[j] >= arr[least]). This is the inverse of the operation found in code.

    IL_0014:  ldloc.3             // load j
    IL_0015:  stloc.1             // set least to j
    IL_0016:  ldloc.3             // load j
    IL_0017:  ldc.i4.1             // push 1, to the stack
    IL_0018:  add                 // add j and 1
    IL_0019:  stloc.3             // update j to the top of the stack
    IL_001a:  ldloc.3             // load j
    IL_001b:  ldarg.0             // load arr
    IL_001c:  ldlen             // put length of arr, on the stack
    IL_001d:  conv.i4             // convert the length to stack
    IL_001e:  blt.s IL_000c        // jump to IL_000c iff (j < arr.length)

    IL_0020:  ldarg.0             // get arr
    IL_0021:  ldloc.0             // get i
    IL_0022:  ldelem.i4         // get arr[i]
    IL_0023:  stloc.2             // store the top of the stack in tmp, the 2'nd var
    IL_0024:  ldarg.0             // get arr
    IL_0025:  ldloc.0             // get i
    IL_0026:  ldarg.0             // get arr
    IL_0027:  ldloc.1             // get least
    IL_0028:  ldelem.i4         // get arr[least]
    IL_0029:  stelem.i4         // set arr[i] to arr[least]
    IL_002a:  ldarg.0             // get arr
    IL_002b:  ldloc.1             // get least
    IL_002c:  ldloc.2             // get tmp
    IL_002d:  stelem.i4         // set arr[least] = tmp
    IL_002e:  ldloc.0             // get i
    IL_002f:  ldc.i4.1             // push 1 to the stack
    IL_0030:  add                 // add i and 1
    IL_0031:  stloc.0             // store the result to i
    IL_0032:  ldloc.0             // get i
    IL_0033:  ldarg.0             // get arr
    IL_0034:  ldlen             // push the length of arr to the stack
    IL_0035:  conv.i4             // convert to int
    IL_0036:  blt.s IL_0004        // jump to IL_0004, iff (i < arr.length)

    IL_0038:  ret                 // return
    } // end of method Selsort::SelectionSort

```

The following code was generated by running `javac`, and `javap` on the Selsort program.
It has been annotated to describe the purpose of the instructions.

```{}
  public static void SelectionSort(int[]);
    descriptor: ([I)V
    flags: (0x0009) ACC_PUBLIC, ACC_STATIC
    Code:
      stack=4, locals=4, args_size=1
         0: iconst_0            // push 0 to the stack
         1: istore_1            // store 0 in index 1, the variable i 
         2: iload_1             // get i
         3: aload_0             // get content of the 0'th variable, the input array
         4: arraylength         // get length of arr
         5: if_icmpge     57    // jump to 57, iff i >= arr.length
         8: iload_1             // get i
         9: istore_2            // store i in, index 2, variable least
        10: iload_1             // get i
        11: iconst_1            // push 1 on the stack
        12: iadd                // add i to 1
        13: istore_3            // store result in variable index 3, j
        14: iload_3             // get j
        15: aload_0             // get arr
        16: arraylength         // get length of arr
        17: if_icmpge     37    // jump to 37, iff j >= arr.length
        20: aload_0             // get arr
        21: iload_3             // get j
        22: iaload              // get arr[j]
        23: aload_0             // get arr
        24: iload_2             // get least
        25: iaload              // get arr[least]
        26: if_icmpge     31    // jump to 31, iff (arr[j] >= arr[least]). The inverse of the code
        29: iload_3             // get j
        30: istore_2            // set least to j
        31: iinc          3, 1  // get j, add 1, store result to j,  j++
        34: goto          14    // jump 14
        37: aload_0             // get arr
        38: iload_1             // get i 
        39: iaload              // get arr[i]
        40: istore_3            // store arr[i] to j
        41: aload_0             // get arr
        42: iload_1             // get i
        43: aload_0             // get arr
        44: iload_2             // get least
        45: iaload              // get arr[least]
        46: iastore             // set arr[i] to arr[least]
        47: aload_0             // get arr
        48: iload_2             // get least 
        49: iload_3             // get j
        50: iastore             // set arr[least] to j
        51: iinc          1, 1  // get i, add 1, store result to i, i++
        54: goto          2     // jump 2
        57: return              // return
```

## 9.2

Skipped, for now.

## 9.3

The upgraded code is seen below.
Only one line has been changed, the line `dummy.next = null;`, has been added to the `get` method.
This works, by removing the reference to the first real element of the list.
The problem was that dummy kept a useless reference, to the head element, preventing full garbage collection.

```{}
class SentinelLockQueue implements Queue {  
  // With sentinel (dummy) node.
  // Invariants:
  //  * The node referred by tail is reachable from head.
  //  * If non-empty then head != tail, 
  //     and tail points to last item, and head.next to first item.
  //  * If empty then head == tail.

  private static class Node {
    final int item;
    volatile Node next;
    
    public Node(int item, Node next) {
      this.item = item;
      this.next = next;
    }
  }

  private final Node dummy = new Node(-444, null);
  private Node head = dummy, tail = dummy;
  
  public synchronized boolean put(int item) {
    Node node = new Node(item, null);
    tail.next = node;
    tail = node;
    return true;
  }

  public synchronized int get() {
    if (head.next == null) 
      return -999;
    Node first = head;
    head = first.next;
    dummy.next = null;
    return head.item;
  }
}
```
